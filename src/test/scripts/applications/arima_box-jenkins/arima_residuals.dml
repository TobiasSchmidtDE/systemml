#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------
# Arguments
# 'X': X (one column time series - there has to be an .mtd file associated to the src file!)
# 'weights': (overwrites weights_src arg!) initialization string for weight matrix, see DML language documentation for matrix constructor using initialization string
# 'weights_src': path to weights file / arima model generated by arima training script
# Optional:
# 'p': p (non-seasonal AR order) (default 0)
# 'd': d (non-seasonal differencing order) (default 0)
# 'q': q (non-seasonal MA order) (default 0)
# 'P': P (seasonal AR order) (default 0)
# 'D': D (seasonal differencing order)(default 0)
# 'Q': Q (seasonal MA order)(default 0)
# 's': s (period in terms of number of time-steps) (default 1)
# 'solver': must be either 'cg' for conjugate gradients method or 'jacobi' for jacobi method (default "jacobi")
# 'dest': file name to store learnt parameters (default "arima-residuals")
# 'result_format': the format of the destination file (default "text")


arima_predict = function(Matrix[Double] weights, Matrix[Double] Z, Integer p, Integer P, Integer q, Integer Q, Integer s, String solver) return (Matrix[Double] approximated_solution, Matrix[Double] combined_weights){

	combined_weights = weights
	if (p>0 & P>0){
		combined_weights = rbind(combined_weights, matrix(weights[1:p,] %*% t(weights[p+1:p+P,]), rows=p*P, cols=1))
	}
	if (q>0 & Q>0){
		combined_weights = rbind(combined_weights, matrix(weights[p+P+1:p+P+q,] %*% t(weights[p+P+q+1:p+P+q+Q,]), rows=q*Q, cols=1))
	}

	b = Z%*%combined_weights
	R = matrix(0, nrow(Z), nrow(Z))
	for(i in seq(1, q, 1)){
		d_ns = matrix(as.scalar(weights[P+p+i,1]), nrow(R)-i, 1)
		R[1+i:nrow(R),1:ncol(R)-i] = R[1+i:nrow(R),1:ncol(R)-i] + diag(d_ns)
	}

	for(i in seq(1, Q, 1)){
		err_ind_s = s*i
		d_s = matrix(as.scalar(weights[P+p+q+i,1]), nrow(R)-err_ind_s, 1)
		R[1+err_ind_s:nrow(R),1:ncol(R)-err_ind_s] = R[1+err_ind_s:nrow(R),1:ncol(R)-err_ind_s] + diag(d_s)
	}
	approximated_solution = b #solve(R,b)
}

#This function is used to calculate the error that occures when predicting using the given weights
arima_residuals = function(Matrix[Double] weights, Matrix[Double] X, Matrix[Double] Z, Integer p, Integer P, Integer q, Integer Q, Integer s, String solver) return (Matrix[Double] errs, Matrix[Double] combined_weights){
	[approximated_solution, combined_weights] = arima_predict(weights, Z, p, P, q, Q, s, solver)
	errs = X - approximated_solution
}


#inserts the first column of source matrix into the n-th column of target matrix with the specified row offset
addShiftedMatrix = function (Matrix[Double] targetMatrix, Matrix[Double] sourceMatrix, Integer rowOffset, Integer nthColumn) return (Matrix[Double] targetMatrix){
	targetMatrix[rowOffset+1:nrow(targetMatrix), nthColumn] = sourceMatrix[1:nrow(targetMatrix)-rowOffset, 1]
}


addValuesForCombinedModel = function (Matrix[Double] targetMatrix, Matrix[Double] sourceMatrix, Integer nonSeasonalParam, Integer seasonalParam, Integer seasonality, Integer columnOffset)return (Matrix[Double] targetMatrix){
	counter = 1
	for	(k in seq(1, nonSeasonalParam, 1)){
		for(j in seq(1, seasonalParam, 1)){
			targetMatrix = addShiftedMatrix(targetMatrix, sourceMatrix, k + (j*seasonality), columnOffset + counter)
			counter+=1
		}
	}
	#for combination of non seasonal and seasonal model the sign has to be inverted:
	if (nonSeasonalParam>0&seasonalParam>0) {
		targetMatrix[,columnOffset+1:columnOffset+nonSeasonalParam*seasonalParam] = -targetMatrix[,columnOffset+1:columnOffset+nonSeasonalParam*seasonalParam]
	}
}

difference = function (Matrix[Double] X, Integer d, Integer D, Integer s) return (Matrix[Double] X){
	# d-th order differencing:
	for(i in seq(1,d,1)){
		X = X[2:nrow(X),] - X[1:nrow(X)-1,]
	}

	# D-th order differencing:
	for(i in seq(1,D,1)){
		n1 = nrow(X)+0.0
		X = X[s+1:n1,] - X[1:n1-s,]
	}
}

#Construts Matrix Z with all values that can be used to calculate an approximation of the timeseries in X.
#Each row in Z is used to predict the same value in the corresponding row of X
#Columns of Z represent values used for predicting either AR, SAR, MA or SMA
#p+P cols for ar & sar
#q+Q cols for ma & sma
#p*P cols as tmp parameter when combining season and non seasonal AR
constructPredictorMatrix = function (Matrix[Double] X, Integer p, Integer P, Integer q, Integer Q, Integer s)return( Matrix[Double] Z){
	Z = matrix(0, nrow(X), p+P+Q+q+p*P+q*Q)

	# fills Z with values used for non seasonal AR prediction
	for	(i in seq(1, p, 1)){
		Z = addShiftedMatrix(Z, X, i, i)
	}

	#prediction values for seasonal AR
	for(i in seq(1, P, 1)){
		Z = addShiftedMatrix(Z, X, (i * s), p + i)
	}

	#prediction values for combined models of non-seasonal and seasonal AR
	Z = addValuesForCombinedModel (Z, X, p, P, s, p + P)

	#prediction values for non seasonal MA
	for(i in seq(1, q, 1)){
		Z = addShiftedMatrix(Z, X, i, p + P + p*P + i)
	}

	#prediction values for seasonal MA
	for(i in seq(1,Q, 1)){
		Z = addShiftedMatrix(Z, X, (i * s), p + P + p*P + q + i)
	}

	#prediction values for combined models of non-seasonal and seasonal MA
	Z = addValuesForCombinedModel (Z, X, q, Q, s, p + P + p*P + q + Q )
}

#input col of time series data
X = read($X)
solver = ifdef($solver, "jacobi")
dest = ifdef($dest, "arima-residuals")
result_format = ifdef($result_format, "text")

#non-seasonal order
p =	ifdef($p, 0)
d = ifdef($d, 0)
q = ifdef($q, 0)

#seasonal order
P = ifdef($P, 0)
D = ifdef($D, 0)
Q = ifdef($Q, 0)

#length of the season
s = ifdef($s, 1)

#weights
init_string = ifdef($weights, "undefined")
if (init_string != "undefined"){
	weights = matrix (init_string, p+P+q+Q, 1)
	debug("Init string for weights provided: ")
}
else{
	weights_src = ifdef ($weights_src, "arima-result")
	debug("Init string for weights not provided try reading from weights file under: " + weights_src)
	weights = read(weights_src)
}

print ("weights intitialized with: \n" + toString(weights))
debug ("p= " + p)
debug ("d= " + d)
debug ("q= " + q)
debug ("P= " + P)
debug ("D= " + D)
debug ("Q= " + Q)
debug ("s= " + s)
debug ("solver= " + solver)
debug ("source= " + $X)
debug ("dest= " + dest)
debug ("result_format= " + result_format)


num_rows = nrow(X)
debug("nrows of X: " + num_rows)

if(num_rows <= d){
	warning("non-seasonal differencing order should be smaller than length of the time-series")
}
if(num_rows <= s*D){
	warning("seasonal differencing order should be smaller than number of observations divided by length of season")
}

X = difference (X, d, D, s)

Z = constructPredictorMatrix(X, p, P, q, Q, s)

debug("Z Matrix of size "+nrow(Z)+"x"+ncol(Z)+":\n" + toString( cbind (seq(1,nrow(Z)), Z)))

residuals = arima_residuals (weights, X, Z, p, P, q, Q, s, solver)

write(residuals, dest, format = result_format)

debug = function (String msg){
	verbosePrint("INFO: " + msg)
}
warning = function (String msg){
	print("WARNING: " + msg)
}
verbosePrint = function (String msg){
	verbose = ifdef($verbose, FALSE)
	if (verbose){
		print(msg)
	}
}
