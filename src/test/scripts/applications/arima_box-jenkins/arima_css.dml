#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# Arguments
# 'X': X (one column time series - there has to be an .mtd file associated to the src file!)
# 'weights': (overwrites weights_src arg!) initialization string for weight matrix, see DML language documentation for matrix constructor using initialization string
# 'weights_src': path to weights file / arima model generated by arima training script
# 'p': p (non-seasonal AR order) (default 0)
# 'd': d (non-seasonal differencing order) (default 0)
# 'q': q (non-seasonal MA order) (default 0)
# 'P': P (seasonal AR order) (default 0)
# 'D': D (seasonal differencing order)(default 0)
# 'Q': Q (seasonal MA order)(default 0)
# 's': s (period in terms of number of time-steps) (default 1)
# 'solver': must be either 'forwardsub' for forward subsitution method or 'jacobi' for jacobi method or 'inverse' for directly calculating the inverse (default "jacobi")
# 'dest': file name to store learnt parameters (default "arima-result.csv")
# 'result_format': the format of the destination file (default "csv")


arima_predict = function(Matrix[Double] weights, Matrix[Double] Z, Integer p, Integer q, Integer P, Integer Q, Integer s, Integer ncond, String solver) return (Matrix[Double] x_hat){

	if (p > 0) phi = weights[1:p]
  if (q > 0) theta = weights[(p+1):(p+q)]
	if (P > 0) Phi = weights[(p+q+1):(p+q+P)]
  if (Q > 0) Theta = weights[(p+q+P+1):(p+q+P+Q)]

  multiplicativeWeights = weights
	if (p>0 & P>0){
		multiplicativePhi = matrix(phi %*% t(Phi), rows=p*P, cols=1)
		multiplicativeWeights = rbind(multiplicativeWeights, multiplicativePhi)
	}

	if (q>0 & Q>0){
		multiplicativeTheta = matrix(theta %*% t(Theta), rows=q*Q, cols=1)
		multiplicativeWeights = rbind(multiplicativeWeights, multiplicativeTheta)
	}

	b = Z %*% multiplicativeWeights

	A = diag(matrix(1, nrow(Z), 1)) #identity matrix

	if (q > 0){
    for(i in 1:q){
      A = addDiagonalToMatrix (A, as.scalar(theta[i]), nrow(A)-i)
    }
  }

	if (Q > 0){
    for(i in 1:Q){
    	A = addDiagonalToMatrix (A, as.scalar(Theta[i]), nrow(A)-(i*s))
    }
  }

	if (q > 0 & Q > 0){
    for(i in 1:q){
      for(j in 1:Q){
        A = addDiagonalToMatrix (A, as.scalar(theta[i]*Theta[j]), nrow(A)-(i + j*s))
   		}
		}
	}
	x_hat = eval(solver + "_solver", A, b)
}

arima_residuals = function(Matrix[Double] weights, Matrix[Double] X, Matrix[Double] Z, Integer p, Integer q, Integer P, Integer Q, Integer s, Integer ncond, String solver) return (Matrix[Double] residuals){
	x_hat = arima_predict(weights, Z, p, q, P, Q, s, ncond, solver)
  residuals = X - x_hat
	if (ncond > 0) residuals[1:ncond] = matrix (0, rows = ncond, cols = 1)
}

arima_sumofsquares = function(Matrix[Double] weights, Matrix[Double] X, Matrix[Double] Z, Integer p, Integer q, Integer P, Integer Q, Integer s, Integer ncond, String solver) return (Double sumofsquares){
	residuals = arima_residuals(weights, X, Z, p, q, P, Q, s, ncond, solver)
  sumofsquares = sum(residuals^2)/(nrow(X) - ncond)
	print(sumofsquares)
}

arima_css = function(Matrix[Double] weights, Matrix[Double] X, Matrix[Double] Z, Integer p, Integer q, Integer P, Integer Q, Integer s, Integer ncond, String solver) return (Double css){
	css = 0.5 * log (arima_sumofsquares(weights, X, Z, p, q, P, Q, s, ncond, solver))
}

inverse_solver = function (Matrix[Double] A, Matrix[Double] b)  return (Matrix[Double] x){
	invA = L_triangular_inv(A);
	x = invA %*% b
}

# Inverse of lower triangular matrix
L_triangular_inv = function(Matrix[double] L) return(Matrix[double] A) {
  n = ncol(L)
  if (n == 1) {
    A = 1/L[1,1]
  }
  else if (n == 2) {
    A = matrix(0, 2, 2)
    A[1,1] = L[2,2]
    A[2,2] = L[1,1]
    A[2,1] = -L[2,1]
    A = A/(as.scalar(L[1,1] * L[2,2]))
  }
  else {
    k = as.integer(floor(n/2))

    L11 = L[1:k,1:k]
    L21 = L[k+1:n,1:k]
    L22 = L[k+1:n,k+1:n]

    A11 = L_triangular_inv(L11)
    A22 = L_triangular_inv(L22)
    A12 = matrix(0, nrow(A11), ncol(A22))
    A21 = -A22 %*% L21 %*% A11

    A = rbind(cbind(A11, A12), cbind(A21, A22))
  }
}

jacobi_solver = function (Matrix[Double] A, Matrix[Double] b)  return (Matrix[Double] x){
	tolerance = 1.0E-8
	max_iterations = 1000

	x = matrix(0, nrow(A), 1)
  iter = 0
 	diff = tolerance+1
 	diagVector_A = diag(A)
 	rest_A = A - diag(diagVector_A)

 	while(iter < max_iterations & diff > tolerance){
 		x_new =1/diagVector_A * (b - rest_A %*% x)
 		diff =sum(abs(x_new-x))
 		x = x_new
 		iter = iter + 1
 	}
}

forwardsub_solver = function (Matrix[Double] A, Matrix[Double] b)  return (Matrix[Double] x){
	x = matrix(0, nrow(A), 1)
  for (i in 1:nrow(A)){
    x[i,1] = (b[i,1] - A[i,] %*% x[,1]) / A[i,i]
  }
}

addDiagonalToMatrix = function (Matrix[Double] M, Double diagValue, Integer diagSize)return (Matrix[Double] M){
    diagonal = diag(matrix(diagValue, diagSize, 1))
    startRow = nrow(M) - diagSize + 1
    endRow = nrow(M)
    startCol = 1
    endCol = diagSize
    M[startRow:endRow, startCol:endCol] = M[startRow:endRow, startCol:endCol] + diagonal
}

#inserts the first column of source matrix into the n-th column of target matrix with the specified row offset
addShiftedMatrix = function (Matrix[Double] targetMatrix,  Matrix[Double] sourceMatrix, Integer rowOffset, Integer nthColumn)return (Matrix[Double] targetMatrix){
    targetMatrix[(rowOffset+1):nrow(targetMatrix), nthColumn] = sourceMatrix[1:(nrow(targetMatrix)-rowOffset)]
}

addValuesForCombinedModel = function (Matrix[Double] targetMatrix, Matrix[Double] sourceMatrix, Integer nonSeasonalParam, Integer seasonalParam, Integer seasonality, Integer columnOffset)return (Matrix[Double] targetMatrix){
  counter = 1
	if (nonSeasonalParam > 0 & seasonalParam > 0){
    	for	(k in 1:nonSeasonalParam){
    		for(j in 1:seasonalParam){
    			targetMatrix = addShiftedMatrix(targetMatrix, sourceMatrix, k + (j*seasonality), columnOffset + counter)
    			counter = counter+1
    		}
    	}
	}
}

#Construts Matrix Z with all values that can be used to calculate an approximation of the timeseries in X.
#Each row in Z is used to predict the value in the corresponding row of X
#Columns of Z represent values used for predicting either AR, SAR, MA or SMA
#p+P cols for ar & sar
#q+Q cols for ma & sma
#p*P cols for multiplicative SAR
#q*Q cols for multiplicative SMA
constructPredictorMatrix = function(Matrix[Double] X, Integer p, Integer q, Integer P, Integer Q, Integer s, Integer ncond) return (Matrix[Double] Z){
  totalColumns = p + P + Q + q + p*P + q*Q
	Z = matrix(0, rows = nrow(X), cols =totalColumns)

  # fills Z with values used for non seasonal AR prediction
  if (p > 0){
    for(i in 1:p){
      Z = addShiftedMatrix(Z, X, i, i)
    }
  }

  #prediction values for non seasonal MA
  if (q > 0){
    for(i in 1:q){
      Z = addShiftedMatrix(Z, X, i, p + i)
    }
  }

  #prediction values for seasonal AR
  if (P > 0){
    for(i in 1:P){
      Z = addShiftedMatrix(Z, X, (i * s), p + q + i)
    }
  }

  #prediction values for seasonal MA
  if (Q > 0){
    for(i in 1:Q){
      Z = addShiftedMatrix(Z, X, (i * s), p + q + P + i)
    }
  }

  #prediction values for combined models of non-seasonal and seasonal AR
  #for multiplicative AR the sign has to be inverted
  Z = addValuesForCombinedModel (Z, (-1) * X, p, P, s, p + P + q + Q)

  #prediction values for combined models of non-seasonal and seasonal MA
  Z = addValuesForCombinedModel (Z, X, q, Q, s, p + P + q + Q + p*P)

  if (ncond > 0){
    Z[1:ncond,] = matrix(0, rows = ncond, cols = totalColumns)
    if (q > 0){
      for (i in 1:q){
				ignoreRows = min(ncond+i, nrow(Z))
        Z[1:ignoreRows,(p+i)] = matrix(0, rows = ignoreRows, cols = 1)
      }
    }
	  if (Q > 0){
      for (i in 1:Q){
				ignoreRows = min(ncond+(i*s), nrow(Z))
        Z[1:ignoreRows,(p+q+P+i)] = matrix(0, rows = ignoreRows, cols = 1)
      }
	  }
	  if (q > 0 & Q > 0){
	    count = 1
	    for(i in 1:q){
        for(j in 1:Q){
					ignoreRows = min(ncond+(i+j*s), nrow(Z))
          Z[1:ignoreRows,(p+q+P+Q+P*p+count)] = matrix(0, rows = ignoreRows, cols = 1)
          count = count + 1;
        }
     	}
		}
	}
}


difference = function (Matrix[Double] X, Integer d, Integer D, Integer s) return (Matrix[Double] X){
	# d-th order non seasonal differencing:
	if (d > 0){
        for(i in 1:d){
    	    X[2:nrow(X)] = X[2:nrow(X)] - X[1:(nrow(X)-1)]
    	}
    }
	# D-th order seasonal differencing:
	if (D > 0){
        for(i in 1:D){
    	    X[(s+1):nrow(X)] = X[(s+1):nrow(X)] - X[1:(nrow(X)-s)]
        }
	}
}


X = read($X)

solver = ifdef($solver, "jacobi")
dest = ifdef($dest, "arima-css.csv")
result_format = ifdef($result_format, "text")

#n on-seasonal order
p =	ifdef($p, 0)
d = ifdef($d, 0)
q = ifdef($q, 0)

# seasonal order
P = ifdef($P, 0)
D = ifdef($D, 0)
Q = ifdef($Q, 0)

# length of the season
s = ifdef($s, 0)

# The number of initial observations to ignore. It will be ignored if less than the maximum lag of an AR term. Also ignores
ncond = d + D*s + p + P*s

arima_string = "arima(p="+p+", d="+d+", q="+q+")(P="+P+", D="+D+", Q="+Q+", s="+s+")"


# weights
weights_string = ifdef($weights, "")
weights_src = ifdef ($weights_src, "")

# number of weights that are expected
nweights = p+P+q+Q
if (weights_string != ""){
	# TODO: check weights string contains exactly nweights.
	# Otherwise a weights_string with less then nweights entries will also work
	weights = matrix (weights_string, nweights, 1)
}
else if (weights_src != ""){
	weights = read(weights_src)
}
# check weights not empty:
else{
	print ("ERROR: IllegalArgument: No weights provided!")
	stop ("Stopped because of IllegalArgument")
}

# check at least one arima order p, q, P, Q not 0
if (p == 0 & q == 0 & P == 0 & Q == 0){
	print ("ERROR: IllegalArgument: Calculating "+arima_string+" is not possible. At least one of the arguments p, q, P or Q must be a non-zero!")
	stop ("Stopped because of IllegalArgument")
}

# check no arima order p, q, P, Q is negative
if (p < 0 | d < 0 | q < 0 | P < 0 | D < 0 | Q < 0){
	print ("ERROR: IllegalArgument: Calculating "+arima_string+" is not possible. There mustn't be any negative arguments!")
	stop ("Stopped because of IllegalArgument")
}

# check seasonality s is greater 1 is given if seasonal model is selected
if ((P != 0 | Q != 0 | D != 0) & s < 1){
	print ("ERROR: IllegalArgument: The seasonality s has to be at least 1 if any seasonal order is non-zero. Seasonal orders are P="+P+", D="+D+", Q="+Q+" but s="+s)
	stop ("Stopped because of IllegalArgument")
}

# check solver is jacobi|forwardsub|inverse
if (solver != "jacobi" & solver != "forwardsub" & solver != "inverse"){
	print ("ERROR: IllegalArgument: Solver must be either 'forwardsub' for forward subsitution method, 'jacobi' for jacobi method or 'inverse' for directly calculating the inverse.")
	stop ("Stopped because of IllegalArgument")
}

# check time series has sufficent amount of data.
if (ncond > nrow(X)){
	print ("ERROR: IllegalArgument: The time series X does not provide enough data points to calculate "+ arima_string+ ". At least "+ncond+" data points are needed!")
	stop ("Stopped because of IllegalArgument")
}

# check number of weights provided:
if (nrow(weights) != nweights | ncol(weights) != 1){
	print ("ERROR: IllegalArgument: Weights are of wrong dimension. Weights matrix dimension should be [" + nweights + ":1] but is [" + nrow(weights) + ":"+ ncol(weights) +"] instead. Check your weights file " + weights_src)
	stop ("Stopped because of IllegalArgument")
}


print ("")
print ("p = " + p)
print ("d = " + d)
print ("q = " + q)
print ("P = " + P)
print ("D = " + D)
print ("Q = " + Q)
print ("s = " + s)
print ("ncond = " + ncond)
print ("solver = " + solver)
print ("dest = " + dest)
print ("result_format = " + result_format)


diffX = difference(X, d, D, s)
Z = constructPredictorMatrix(diffX, p, q, P, Q, s, ncond)
css = arima_css(weights, diffX, Z, p, q, P, Q, s, ncond, solver)

print("arima_css = " + css)

write(css, dest)
